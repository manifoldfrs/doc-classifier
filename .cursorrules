# Project Instructions

Your objective is to demonstrate engineering rigor and scalability thinking through a document classifier demo. This is not just about solving a coding challenge—it's about showing maturity in how you architect, write, and think about production-quality systems.

## Tech Stack

- **Backend**: Python + Flask + FastAPI (use async where appropriate)
- **Infra (future-ready)**: GCP / AWS / Terraform (design with cloud scaling in mind)
- **Frontend**: Optional React + TypeScript (hosted on Vercel)
- **CI/CD**: GitHub Actions for test + deploy
- **Testing**: `pytest`

---

## Coding Principles

### Code Quality

- Every module, class, and function must have a single responsibility.
- Keep all logic well-scoped and testable.
- No large functions. Refactor aggressively.
- Avoid over-engineering; design for change, not complexity.

### Readability & Maintainability

- Use clear, intention-revealing names.
- Don’t write clever code. Write code that a new hire at Heron could understand in one read.
- Use docstrings only when the code’s intent isn’t self-evident.

### Modularity & Structure

- Break features into logical modules:
  - ingestion/, classification/, parsing/, api/, tests/
- Avoid deep inheritance and tight coupling. Prefer composition and isolation.

---

## Python Best Practices

- Follow **PEP8** for formatting.
- Use **type hints** and enforce them (`mypy` optional but preferred).
- Use `dataclasses` or `Pydantic` models for structure.
- Avoid catching general `Exception`. Be specific.
- Handle async/await where I/O is involved.

### Logging

- Use Python’s `logging` module.
- Use levels wisely: DEBUG for dev-only info, INFO for lifecycle events, ERROR for failures.
- Avoid `print()` outside of debugging.

---

## FastAPI Best Practices

- Use **Pydantic** for request validation and data typing.
- Create **separate routers** for organization.
- Async all endpoint handlers unless doing CPU-bound work.
- Handle errors using global exception handlers.
- Stick to REST conventions. Use clear HTTP status codes.

---

## Scalability Considerations

- Design every core component as if it may process **millions of files/day**.
- Plan for:
  - Distributed task queues (e.g., Celery)
  - Pluggable model backends
  - External file storage (e.g., S3) in production
- Avoid blocking I/O. Stream files and process in-memory for the demo.
- Simulate retry logic, even if not needed for demo scale.

---

## Testing

- Use `pytest`
- Every pure function must have a test.
- Test edge cases: empty files, bad filenames, corrupt metadata

---

## Deployment Notes

- Project should deploy via Vercel.
- Structure code to later allow Docker-based deployment.
- Environment configs should be isolated and toggleable.
- GitHub Actions should:
  - Run tests
  - Deploy on push to main or tag

---

## General Rules

1. **Functionality**: Classifier must work, fallback reliably, and handle ambiguity.
2. **Code Quality**: Every line added must be clean, scoped, and intentional.
3. **Scalability**: Write today’s code to be replaceable for tomorrow’s needs.
4. **Creativity**: You’re allowed to go beyond the prompt if it makes the system better.
5. **Documentation**: Keep `README.md` up to date. Use it to show thinking, not just commands.

---

## What to Avoid

- Don’t over-comment. Clean code should be self-explanatory.
- Don’t build for multiple users or auth—just simulate the design path.
- Don’t reach for big ML libraries unless necessary. Keep it lean.
